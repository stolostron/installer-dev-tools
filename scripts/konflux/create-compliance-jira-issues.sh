#!/usr/bin/env bash

set -euo pipefail

# Script to create JIRA issues for non-compliant Konflux components
# Reads the compliance CSV file generated by compliance.sh and creates
# JIRA issues for components that have compliance failures

# Debug helper function
debug_echo() {
    if [[ "$DEBUG" == true ]]; then
        echo -e "$@" >&2
    fi
}

# Load environment variables from .env file if it exists
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/.env" ]]; then
    set -a  # automatically export all variables
    source "$SCRIPT_DIR/.env"
    set +a
fi

show_help() {
    cat << EOF
Usage: create-compliance-jira-issues.sh [OPTIONS] <compliance-csv-file>

Create JIRA issues for non-compliant components from compliance.sh output

ARGUMENTS:
    <compliance-csv-file>    Path to the compliance CSV file (e.g., data/acm-215-compliance.csv)

OPTIONS:
    --project PROJECT        JIRA project key (default: from JIRA_PROJECT env var or "ACM")
    --issue-type TYPE        JIRA issue type (default: "Bug")
    --priority PRIORITY      JIRA priority (default: "Critical")
    --component COMPONENT    JIRA component field (optional, overrides auto-detection from component-squad.yaml)
    --labels LABELS          Comma-separated labels (default: "konflux,compliance,auto-created")
    --dry-run                Show what would be created without actually creating issues
    --skip-duplicates        Skip creating issues if similar ones already exist
    --output-json FILE       Save created issues to JSON file
    --debug                  Enable debug output (shows jira-cli command in dry-run mode)
    -h, --help               Show this help message

NOTE:
    The script automatically sets the JIRA Component/s field based on the squad mapping
    in component-squad.yaml. Each component is mapped to its jira-component value (e.g., "Server Foundation",
    "Installer", "GRC", "HyperShift", etc.). You can override this by using the --component option.

ENVIRONMENT VARIABLES:
    Required (for automatic jira-cli initialization):
        JIRA_USER            Your JIRA username/email (e.g., user@redhat.com)
        JIRA_API_TOKEN       Your JIRA Personal Access Token
        JIRA_AUTH_TYPE       Authentication type (set to "bearer" for PAT)

    Optional:
        JIRA_PROJECT         JIRA project key (default: "ACM")
        JIRA_SERVER          JIRA server URL (default: "https://issues.redhat.com")
        JIRA_INSTALLATION    Installation type: "Cloud" or "Local" (default: "Local")

PREREQUISITES:
    This script requires jira-cli (https://github.com/ankitpokhrel/jira-cli)

    Installation:
    # macOS (Homebrew)
    brew tap ankitpokhrel/jira-cli
    brew install jira-cli

    # Linux (download binary from releases)
    # Visit https://github.com/ankitpokhrel/jira-cli/releases
    # Or use Go:
    go install github.com/ankitpokhrel/jira-cli/cmd/jira@latest

    Configuration (Automatic):
    The script will automatically configure jira-cli if not already set up.
    Just set the required environment variables in .env file:

    cp .env.template .env
    # Edit .env and fill in:
    #   JIRA_USER, JIRA_API_TOKEN, JIRA_AUTH_TYPE
    source .env

    Configuration (Manual):
    Alternatively, you can run jira-cli configuration manually:
    jira init

EXAMPLES:
    # First time setup - set environment variables
    cp .env.template .env
    # Edit .env file with your credentials
    source .env

    # Create issues with default settings
    ./create-compliance-jira-issues.sh data/acm-215-compliance.csv

    # Dry run to preview what would be created
    ./create-compliance-jira-issues.sh --dry-run data/acm-215-compliance.csv

    # Create issues with custom labels and priority
    ./create-compliance-jira-issues.sh --labels "konflux,compliance,auto-created" --priority "Critical" data/acm-215-compliance.csv

    # Skip duplicates and save output
    ./create-compliance-jira-issues.sh --skip-duplicates --output-json issues.json data/acm-215-compliance.csv

CSV FORMAT:
    The compliance CSV file should have the following format (from compliance.sh):
    <component-name>,<build-timestamp>,<promotion-status>,<hermetic-status>,<ec-status>,<multiarch-status>,<pipelinerun-url>

    Each line represents one component with its compliance data.

EOF
}

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
JIRA_PROJECT="${JIRA_PROJECT:-ACM}"
ISSUE_TYPE="Bug"
PRIORITY="Critical"
COMPONENT=""
LABELS="konflux,compliance,auto-created"
DRY_RUN=false
SKIP_DUPLICATES=false
OUTPUT_JSON=""
COMPLIANCE_FILE=""
DEBUG=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --project)
            JIRA_PROJECT="$2"
            shift 2
            ;;
        --issue-type)
            ISSUE_TYPE="$2"
            shift 2
            ;;
        --priority)
            PRIORITY="$2"
            shift 2
            ;;
        --component)
            COMPONENT="$2"
            shift 2
            ;;
        --labels)
            LABELS="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --skip-duplicates)
            SKIP_DUPLICATES=true
            shift
            ;;
        --output-json)
            OUTPUT_JSON="$2"
            shift 2
            ;;
        --debug)
            DEBUG=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "Unknown option: $1"
            echo ""
            show_help
            exit 1
            ;;
        *)
            if [[ -z "$COMPLIANCE_FILE" ]]; then
                COMPLIANCE_FILE="$1"
            else
                echo "Error: Multiple compliance files specified"
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate required parameters
if [[ -z "$COMPLIANCE_FILE" ]]; then
    echo -e "${RED}Error: Compliance CSV file is required${NC}"
    echo ""
    show_help
    exit 1
fi

if [[ ! -f "$COMPLIANCE_FILE" ]]; then
    echo -e "${RED}Error: Compliance file not found: $COMPLIANCE_FILE${NC}"
    exit 1
fi

# Check if jira-cli is installed
if ! command -v jira &> /dev/null; then
    echo -e "${RED}Error: jira-cli is required but not installed${NC}"
    echo ""
    echo "Install jira-cli from: https://github.com/ankitpokhrel/jira-cli"
    echo ""
    echo "macOS (Homebrew):"
    echo "  brew tap ankitpokhrel/jira-cli"
    echo "  brew install jira-cli"
    echo ""
    echo "Linux:"
    echo "  Download from: https://github.com/ankitpokhrel/jira-cli/releases"
    echo "  Or use Go: go install github.com/ankitpokhrel/jira-cli/cmd/jira@latest"
    echo ""
    echo "After installation, the script will configure jira-cli automatically"
    echo "when you run it with the required environment variables set."
    exit 1
fi

# Check if jira-cli is configured
JIRA_CONFIG_FILE="${JIRA_CONFIG_FILE:-$HOME/.config/.jira/.config.yml}"
if [[ ! -f "$JIRA_CONFIG_FILE" ]]; then
    echo -e "${YELLOW}JIRA CLI is not configured. Initializing...${NC}"

    # Validate required environment variables for non-interactive init
    if [[ -z "$JIRA_API_TOKEN" ]]; then
        echo -e "${RED}Error: JIRA_API_TOKEN environment variable is required${NC}"
        echo ""
        echo "Please set the following environment variables:"
        echo "  export JIRA_API_TOKEN=\"your-personal-access-token\""
        echo "  export JIRA_AUTH_TYPE=\"bearer\""
        echo ""
        echo "Or run 'jira init' manually to configure interactively."
        exit 1
    fi

    # Set defaults for jira init
    JIRA_SERVER="${JIRA_SERVER:-https://issues.redhat.com}"
    JIRA_INSTALLATION="${JIRA_INSTALLATION:-Local}"
    JIRA_LOGIN="${JIRA_LOGIN:-${JIRA_USER:-}}"
    JIRA_AUTH_TYPE="${JIRA_AUTH_TYPE:-bearer}"
    # Set board to "None" if not specified (empty string causes interactive prompt)
    JIRA_BOARD="${JIRA_BOARD:-None}"

    echo -e "${BLUE}Initializing jira-cli with:${NC}"
    echo -e "  Server: $JIRA_SERVER"
    echo -e "  Installation: $JIRA_INSTALLATION"
    echo -e "  Auth Type: $JIRA_AUTH_TYPE"
    echo -e "  Project: $JIRA_PROJECT"
    echo -e "  Board: $JIRA_BOARD"
    echo ""

    # Run jira init non-interactively
    if jira init \
        --installation "$JIRA_INSTALLATION" \
        --server "$JIRA_SERVER" \
        --login "$JIRA_LOGIN" \
        --auth-type "$JIRA_AUTH_TYPE" \
        --project "$JIRA_PROJECT" \
        --board "$JIRA_BOARD" \
        --force; then
        echo -e "${GREEN}✓${NC} JIRA CLI initialized successfully"
    else
        echo -e "${RED}✗${NC} Failed to initialize JIRA CLI"
        echo ""
        echo "You can try running 'jira init' manually for interactive setup."
        exit 1
    fi
    echo ""
fi

# Extract application name from filename
# e.g., data/acm-215-compliance.csv -> acm-215
APP_NAME=$(basename "$COMPLIANCE_FILE" | sed 's/-compliance\.csv$//')
echo -e "${BLUE}Processing compliance data for application: $APP_NAME${NC}"

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: jq is required but not installed${NC}"
    echo "Install with: brew install jq (macOS) or apt-get install jq (Linux)"
    exit 1
fi

# Function to get all JIRA component names for a component (handles multi-squad components)
# Only returns jira-component field values, does not fall back to name field
get_component_squads() {
    local component_name="$1"
    local config_file="$SCRIPT_DIR/component-squad.yaml"

    if [[ ! -f "$config_file" ]]; then
        echo ""
        return
    fi

    # Strip version suffix (e.g., -210, -215, -27, -29) from component name
    # Pattern: remove trailing dash followed by digits
    local base_component_name=$(echo "$component_name" | sed 's/-[0-9][0-9]*$//')

    # Search through all squads to find which ones contain this component
    # Try exact match first, then try base name without version suffix
    # Only return jira-component field (do not fall back to name field)
    local jira_components=$(yq ".squads | to_entries | .[] | select(.value.components[] == \"$component_name\") | .value[\"jira-component\"]" "$config_file" 2>/dev/null)

    if [[ -z "$jira_components" && "$base_component_name" != "$component_name" ]]; then
        jira_components=$(yq ".squads | to_entries | .[] | select(.value.components[] == \"$base_component_name\") | .value[\"jira-component\"]" "$config_file" 2>/dev/null)
    fi

    # Filter out empty/null values and return all JIRA component names (one per line)
    echo "$jira_components" | grep -v '^$' | grep -v '^null$'
}

# Function to create JIRA issue
create_jira_issue() {
    local component_name="$1"
    local build_time="$2"
    local promotion_status="$3"
    local hermetic_status="$4"
    local ec_status="$5"
    local multiarch_status="$6"
    local push_status="$7"
    local push_pipelinerun_url="$8"
    local ec_pipelinerun_url="$9"

    # Build description with compliance details
    local description="h2. Component Compliance Failure

*Component:* \`$component_name\`
*Application:* \`$APP_NAME\`
*Build Time:* $build_time

h3. Compliance Status

||Check||Status||
|Image Promotion|$promotion_status|
|Hermetic Builds|$hermetic_status|
|Enterprise Contract|$ec_status|
|Multiarch Support|$multiarch_status|
|Push Pipeline|$push_status|

h3. Required Actions
"

    # Add specific action items based on failures
    if [[ "$promotion_status" =~ (Failed|IMAGE_PULL_FAILURE|INSPECTION_FAILURE|DIGEST_FAILURE) ]]; then
        description+="* Fix image promotion issues - component has no valid promoted image
"
    fi

    if [[ "$hermetic_status" == "Not Enabled" ]]; then
        description+="* Enable hermetic builds:
** Set \`hermetic: true\` in .tekton pipeline YAML
** Set \`build-source-image: true\` in .tekton pipeline YAML
** Add \`prefetch-input\` configuration or vendor dependencies
"
    fi

    if [[ "$ec_status" == "Not Compliant" ]]; then
        description+="* Fix Enterprise Contract violations - check Konflux pipeline logs
"
    fi

    if [[ "$ec_status" == "Push Failure" ]]; then
        description+="* Fix pipeline push failures - component build is failing
"
    fi

    if [[ "$multiarch_status" == "Not Enabled" ]]; then
        description+="* Enable multiarch support:
** Add \`build-platforms\` parameter with 4 platforms: [linux/amd64, linux/arm64, linux/ppc64le, linux/s390x]
"
    fi

    if [[ "$push_status" == "Failed" ]]; then
        description+="* Fix push pipeline failures - check the build pipeline run logs for errors
"
    fi

    description+="
h3. Pipeline Run Links
"

    # Add push pipelinerun link if available
    if [[ -n "$push_pipelinerun_url" && "$push_pipelinerun_url" != "N/A" && "$push_pipelinerun_url" != "null" ]]; then
        description+="
* [Build Pipeline Run|$push_pipelinerun_url]"
    fi

    # Add EC pipelinerun link if available
    if [[ -n "$ec_pipelinerun_url" && "$ec_pipelinerun_url" != "N/A" && "$ec_pipelinerun_url" != "null" ]]; then
        description+="
* [Enterprise Contract Pipeline Run|$ec_pipelinerun_url]"
    fi

    # Build summary
    local summary="[$APP_NAME] $component_name - Konflux compliance failure"

    # Check for duplicates if requested
    if [[ "$SKIP_DUPLICATES" == true ]]; then
        local jql="project=$JIRA_PROJECT AND summary~\"$component_name\" AND labels=konflux AND labels=compliance AND labels=auto-created AND status NOT IN (Closed,Done,Resolved)"

        # Use jira-cli to search for existing issues
        local existing_issues=$(jira issue list --jql "$jql" --plain --no-headers --columns KEY 2>/dev/null || echo "")

        if [[ -n "$existing_issues" ]]; then
            local existing_key=$(echo "$existing_issues" | head -n 1 | awk '{print $1}' | xargs)
            echo -e "${YELLOW}⊘${NC} Skipping $component_name - similar issue already exists: $existing_key" >&2
            echo "$existing_key"  # Output existing issue key for tracking
            return 0
        fi
    fi

    # Create a temporary file for the description
    local desc_file=$(mktemp)
    echo "$description" > "$desc_file"

    # Build jira-cli command arguments
    local jira_cmd_args=(
        "issue" "create"
        "--project" "$JIRA_PROJECT"
        "--type" "$ISSUE_TYPE"
        "--priority" "$PRIORITY"
        "--summary" "$summary"
        "--template" "$desc_file"
        "--custom" "activity-type=Quality / Stability / Reliability"
        "--custom" "severity=Critical"
        "--no-input"
    )

    # Add labels
    if [[ -n "$LABELS" ]]; then
        IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
        for label in "${LABEL_ARRAY[@]}"; do
            label=$(echo "$label" | xargs)  # trim whitespace
            jira_cmd_args+=("--label" "$label")
        done
    fi

    # Add component(s) - use squad name(s) from component-squad.yaml unless overridden
    if [[ -n "$COMPONENT" ]]; then
        # User specified component override - use it
        jira_cmd_args+=("--component" "$COMPONENT")
    else
        # Look up squad name(s) for this component
        local squad_names=$(get_component_squads "$component_name")
        if [[ -n "$squad_names" ]]; then
            # Add each squad as a separate JIRA component
            while IFS= read -r squad_name; do
                if [[ -n "$squad_name" ]]; then
                    jira_cmd_args+=("--component" "$squad_name")
                fi
            done <<< "$squad_names"
        fi
    fi

    # Handle dry-run mode - show what would be created (after building the command)
    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}[DRY RUN]${NC} Would create issue:" >&2
        echo -e "${BLUE}Summary:${NC} $summary" >&2
        echo -e "${BLUE}Project:${NC} $JIRA_PROJECT" >&2
        echo -e "${BLUE}Type:${NC} $ISSUE_TYPE" >&2
        echo -e "${BLUE}Priority:${NC} $PRIORITY" >&2
        echo -e "${BLUE}Labels:${NC} $LABELS" >&2

        # Show component(s) if any
        local components_list=""
        for arg_idx in "${!jira_cmd_args[@]}"; do
            if [[ "${jira_cmd_args[$arg_idx]}" == "--component" ]]; then
                local next_idx=$((arg_idx + 1))
                if [[ -n "$components_list" ]]; then
                    components_list+=", "
                fi
                components_list+="${jira_cmd_args[$next_idx]}"
            fi
        done
        if [[ -n "$components_list" ]]; then
            echo -e "${BLUE}Component(s):${NC} $components_list" >&2
        fi

        # If debug is enabled, show the full jira-cli command
        if [[ "$DEBUG" == true ]]; then
            echo "" >&2
            echo -e "${BLUE}Command:${NC}" >&2
            echo -n "jira" >&2
            for arg in "${jira_cmd_args[@]}"; do
                if [[ "$arg" =~ [[:space:]] ]]; then
                    echo -n " \"$arg\"" >&2
                else
                    echo -n " $arg" >&2
                fi
            done
            echo "" >&2
            echo "" >&2
            echo -e "${BLUE}Description content:${NC}" >&2
            cat "$desc_file" >&2
        fi

        echo "" >&2
        rm -f "$desc_file"
        echo "DRY-RUN-ISSUE"  # Output placeholder for dry-run mode (stdout for capture)
        return 0
    fi

    # Create the issue using jira-cli
    # If debug is enabled, print the command being executed
    if [[ "$DEBUG" == true ]]; then
        debug_echo "${BLUE}Executing command:${NC}"
        debug_echo -n "jira"
        for arg in "${jira_cmd_args[@]}"; do
            if [[ "$arg" =~ [[:space:]] ]]; then
                debug_echo -n " \"$arg\""
            else
                debug_echo -n " $arg"
            fi
        done
        debug_echo ""
        debug_echo ""
        debug_echo "${BLUE}Description content:${NC}"
        debug_echo "$(cat "$desc_file")"
        debug_echo ""
    fi

    local output
    output=$(jira "${jira_cmd_args[@]}" 2>&1)
    local exit_code=$?

    # Clean up temp file
    rm -f "$desc_file"

    # Extract issue key from output
    # jira-cli typically outputs: "Issue created: PROJECT-123" or similar
    local issue_key=$(echo "$output" | grep -oE '[A-Z]+-[0-9]+' | head -n 1)

    if [[ $exit_code -eq 0 && -n "$issue_key" ]]; then
        # Get JIRA URL from jira-cli config
        local jira_url=$(jira config list 2>/dev/null | grep "server:" | awk '{print $2}' || echo "")
        if [[ -z "$jira_url" ]]; then
            jira_url="https://issues.redhat.com"
        fi
        echo -e "${GREEN}✓${NC} Created issue $issue_key for $component_name: $jira_url/browse/$issue_key" >&2
        echo "$issue_key"  # Output issue key for capture
        return 0
    else
        echo -e "${RED}✗${NC} Failed to create issue for $component_name: $output"
        return 1
    fi
}

# Function to check if a component is non-compliant
is_non_compliant() {
    local promotion_status="$1"
    local hermetic_status="$2"
    local ec_status="$3"
    local multiarch_status="$4"
    local push_status="$5"

    # Check for any failure conditions
    if [[ "$promotion_status" =~ (Failed|IMAGE_PULL_FAILURE|INSPECTION_FAILURE|DIGEST_FAILURE) ]] || \
       [[ "$hermetic_status" == "Not Enabled" ]] || \
       [[ "$ec_status" =~ (Not Compliant|Push Failure) ]] || \
       [[ "$multiarch_status" == "Not Enabled" ]] || \
       [[ "$push_status" == "Failed" ]]; then
        return 0  # true - is non-compliant
    fi

    return 1  # false - is compliant
}

# Main processing
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Konflux Compliance JIRA Issue Creator${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Project:${NC} $JIRA_PROJECT"
echo -e "${BLUE}Application:${NC} $APP_NAME"
echo -e "${BLUE}JIRA Auth Type:${NC} ${JIRA_AUTH_TYPE:-not set}"
echo ""

# Read compliance data from CSV
# The CSV format is: component_name,build_time,promotion_status,hermetic_status,ec_status,multiarch_status,push_status,push_pipelinerun_url,ec_pipelinerun_url
created_count=0
skipped_count=0
failed_count=0
total_count=0

declare -a created_issues
declare -a created_issues_json

echo -e "${BLUE}Starting to process CSV file: $COMPLIANCE_FILE${NC}" >&2
echo -e "${BLUE}File exists: $(test -f "$COMPLIANCE_FILE" && echo yes || echo no)${NC}" >&2
echo -e "${BLUE}File content (first 3 lines):${NC}" >&2
head -3 "$COMPLIANCE_FILE" >&2
echo "" >&2

while IFS=',' read -r component_name build_time promotion_status hermetic_status ec_status multiarch_status push_status push_pipelinerun_url ec_pipelinerun_url; do
    total_count=$((total_count + 1))
    echo -e "${BLUE}DEBUG: Read line $total_count: component=$component_name${NC}" >&2

    # Skip empty lines
    if [[ -z "$component_name" ]]; then
        continue
    fi

    # Check if component is non-compliant
    if is_non_compliant "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status"; then
        echo -e "${BLUE}Processing:${NC} $component_name"

        issue_output=$(create_jira_issue "$component_name" "$build_time" "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status" "$push_pipelinerun_url" "$ec_pipelinerun_url")
        create_exit_code=$?

        if [[ $create_exit_code -eq 0 ]]; then
            created_count=$((created_count + 1))
            # Extract the issue key (last line of output) and trim whitespace
            issue_key=$(echo "$issue_output" | tail -n 1 | xargs)
            created_issues+=("$component_name:$issue_key")
            if [[ -n "$OUTPUT_JSON" ]]; then
                # Store in JSON format as well
                created_issues_json+=("{\"component\": \"$component_name\", \"status\": \"created\", \"issue_key\": \"$issue_key\"}")
            fi
        else
            failed_count=$((failed_count + 1))
        fi
    else
        echo -e "${GREEN}✓${NC} $component_name is compliant - skipping"
        skipped_count=$((skipped_count + 1))
    fi

done < "$COMPLIANCE_FILE"

# Save output JSON if requested
if [[ -n "$OUTPUT_JSON" && "${created_count}" -gt 0 ]]; then
    printf "[%s]\n" "$(IFS=,; echo "${created_issues_json[*]}")" | jq '.' > "$OUTPUT_JSON"
    echo -e "${GREEN}✓${NC} Saved created issues to $OUTPUT_JSON"
fi

# Print summary
echo ""
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Summary${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "Total components processed: $total_count"
echo -e "${GREEN}Compliant (skipped):${NC} $skipped_count"
echo -e "${GREEN}Issues created:${NC} $created_count"
echo -e "${RED}Failed:${NC} $failed_count"

# Print list of created issues with URLs
if [[ "${created_count}" -gt 0 ]]; then
    echo ""
    echo -e "${BLUE}Issues:${NC}"
    # Get JIRA URL from jira-cli config file directly
    jira_config="${HOME}/.config/.jira/.config.yml"
    if [[ -f "$jira_config" ]]; then
        jira_url=$(grep "^[[:space:]]*server:" "$jira_config" | awk '{print $2}' | tr -d '"' || echo "https://issues.redhat.com")
    else
        jira_url="https://issues.redhat.com"
    fi
    for issue_info in "${created_issues[@]}"; do
        comp_name="${issue_info%%:*}"
        issue_key="${issue_info##*:}"
        # Trim any whitespace from issue key
        issue_key=$(echo "$issue_key" | xargs)
        echo -e "  • $comp_name: $jira_url/browse/$issue_key"
    done
fi

if [[ "$DRY_RUN" == true ]]; then
    echo ""
    echo -e "${YELLOW}This was a dry run. No issues were actually created.${NC}"
    echo -e "Remove --dry-run flag to create issues."
fi

exit 0
