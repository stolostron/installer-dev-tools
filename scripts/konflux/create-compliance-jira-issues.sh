#!/usr/bin/env bash

set -euo pipefail

# Script to create JIRA issues for non-compliant Konflux components
# Reads the compliance CSV file generated by compliance.sh and creates
# JIRA issues for components that have compliance failures

# Debug helper function
debug_echo() {
    if [[ "$DEBUG" == true ]]; then
        echo -e "$@" >&2
    fi
}

# Load environment variables from .env file if it exists
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/.env" ]]; then
    set -a  # automatically export all variables
    source "$SCRIPT_DIR/.env"
    set +a
fi

show_help() {
    cat << EOF
Usage: create-compliance-jira-issues.sh [OPTIONS] <compliance-csv-file>

Create JIRA issues for non-compliant components from compliance.sh output

ARGUMENTS:
    <compliance-csv-file>    Path to the compliance CSV file (e.g., data/acm-215-compliance.csv)

OPTIONS:
    --project PROJECT        JIRA project key (default: from JIRA_PROJECT env var or "ACM")
    --issue-type TYPE        JIRA issue type (default: "Bug")
    --priority PRIORITY      JIRA priority (default: "Critical")
    --component COMPONENT    JIRA component field (optional, overrides auto-detection from component-squad.yaml)
    --labels LABELS          Comma-separated labels (default: "konflux,compliance,auto-created")
    --dry-run                Show what would be created without actually creating issues
    --skip-duplicates        Skip creating issues if similar ones already exist
    --auto-close             Auto-close existing issues for components that are now compliant
    --output-json FILE       Save created issues to JSON file
    --debug                  Enable debug output (shows jira-cli command in dry-run mode)
    -h, --help               Show this help message

NOTE:
    The script automatically sets the JIRA Component/s field based on the squad mapping
    in component-squad.yaml. Each component is mapped to its jira-component value (e.g., "Server Foundation",
    "Installer", "GRC", "HyperShift", etc.). You can override this by using the --component option.

ENVIRONMENT VARIABLES:
    Required (for automatic jira-cli initialization):
        JIRA_USER            Your JIRA username/email (e.g., user@redhat.com)
        JIRA_API_TOKEN       Your JIRA Personal Access Token
        JIRA_AUTH_TYPE       Authentication type (set to "bearer" for PAT)

    Optional:
        JIRA_PROJECT         JIRA project key (default: "ACM")
        JIRA_SERVER          JIRA server URL (default: "https://issues.redhat.com")
        JIRA_INSTALLATION    Installation type: "Cloud" or "Local" (default: "Local")

PREREQUISITES:
    This script requires jira-cli (https://github.com/ankitpokhrel/jira-cli)

    Installation:
    # macOS (Homebrew)
    brew tap ankitpokhrel/jira-cli
    brew install jira-cli

    # Linux (download binary from releases)
    # Visit https://github.com/ankitpokhrel/jira-cli/releases
    # Or use Go:
    go install github.com/ankitpokhrel/jira-cli/cmd/jira@latest

    Configuration (Automatic):
    The script will automatically configure jira-cli if not already set up.
    Just set the required environment variables in .env file:

    cp .env.template .env
    # Edit .env and fill in:
    #   JIRA_USER, JIRA_API_TOKEN, JIRA_AUTH_TYPE
    source .env

    Configuration (Manual):
    Alternatively, you can run jira-cli configuration manually:
    jira init

EXAMPLES:
    # First time setup - set environment variables
    cp .env.template .env
    # Edit .env file with your credentials
    source .env

    # Create issues with default settings
    ./create-compliance-jira-issues.sh data/acm-215-compliance.csv

    # Dry run to preview what would be created
    ./create-compliance-jira-issues.sh --dry-run data/acm-215-compliance.csv

    # Create issues with custom labels and priority
    ./create-compliance-jira-issues.sh --labels "konflux,compliance,auto-created" --priority "Critical" data/acm-215-compliance.csv

    # Skip duplicates and save output
    ./create-compliance-jira-issues.sh --skip-duplicates --output-json issues.json data/acm-215-compliance.csv

    # Auto-close resolved issues
    ./create-compliance-jira-issues.sh --auto-close data/acm-215-compliance.csv

CSV FORMAT:
    The compliance CSV file should have the following format (from compliance.sh):
    <component-name>,<scan-time>,<promoted-time>,<promotion-status>,<hermetic-status>,<ec-status>,<multiarch-status>,<push-status>,<push-url>,<ec-url>

    Each line represents one component with its compliance data.

EOF
}

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Compliance status constants
readonly STATUS_FAILED="Failed"
readonly STATUS_SUCCESSFUL="Successful"
readonly STATUS_NOT_ENABLED="Not Enabled"
readonly STATUS_NOT_COMPLIANT="Not Compliant"
readonly STATUS_PUSH_FAILURE="Push Failure"
readonly STATUS_COMPLIANT="Compliant"
readonly STATUS_ENABLED="Enabled"
readonly STATUS_IMAGE_PULL_FAILURE="IMAGE_PULL_FAILURE"
readonly STATUS_INSPECTION_FAILURE="INSPECTION_FAILURE"
readonly STATUS_DIGEST_FAILURE="DIGEST_FAILURE"

# JIRA field constants
readonly JIRA_ACTIVITY_TYPE="Quality / Stability / Reliability"
readonly JIRA_SEVERITY="Critical"
readonly DEFAULT_LABELS="konflux,compliance,auto-created"
readonly DEFAULT_JIRA_SERVER="https://issues.redhat.com"

# Default values
JIRA_PROJECT="${JIRA_PROJECT:-ACM}"
ISSUE_TYPE="Bug"
PRIORITY="Critical"
COMPONENT=""
LABELS="$DEFAULT_LABELS"
DRY_RUN=false
SKIP_DUPLICATES=false
AUTO_CLOSE=false
OUTPUT_JSON=""
COMPLIANCE_FILE=""
DEBUG=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --project)
            JIRA_PROJECT="$2"
            shift 2
            ;;
        --issue-type)
            ISSUE_TYPE="$2"
            shift 2
            ;;
        --priority)
            PRIORITY="$2"
            shift 2
            ;;
        --component)
            COMPONENT="$2"
            shift 2
            ;;
        --labels)
            LABELS="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --skip-duplicates)
            SKIP_DUPLICATES=true
            shift
            ;;
        --auto-close)
            AUTO_CLOSE=true
            shift
            ;;
        --output-json)
            OUTPUT_JSON="$2"
            shift 2
            ;;
        --debug)
            DEBUG=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "Unknown option: $1"
            echo ""
            show_help
            exit 1
            ;;
        *)
            if [[ -z "$COMPLIANCE_FILE" ]]; then
                COMPLIANCE_FILE="$1"
            else
                echo "Error: Multiple compliance files specified"
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate required parameters
if [[ -z "$COMPLIANCE_FILE" ]]; then
    echo -e "${RED}Error: Compliance CSV file is required${NC}"
    echo ""
    show_help
    exit 1
fi

if [[ ! -f "$COMPLIANCE_FILE" ]]; then
    echo -e "${RED}Error: Compliance file not found: $COMPLIANCE_FILE${NC}"
    exit 1
fi

# Check if jira-cli is installed
if ! command -v jira &> /dev/null; then
    echo -e "${RED}Error: jira-cli is required but not installed${NC}"
    echo ""
    echo "Install jira-cli from: https://github.com/ankitpokhrel/jira-cli"
    echo ""
    echo "macOS (Homebrew):"
    echo "  brew tap ankitpokhrel/jira-cli"
    echo "  brew install jira-cli"
    echo ""
    echo "Linux:"
    echo "  Download from: https://github.com/ankitpokhrel/jira-cli/releases"
    echo "  Or use Go: go install github.com/ankitpokhrel/jira-cli/cmd/jira@latest"
    echo ""
    echo "After installation, the script will configure jira-cli automatically"
    echo "when you run it with the required environment variables set."
    exit 1
fi

# Check if jira-cli is configured
JIRA_CONFIG_FILE="${JIRA_CONFIG_FILE:-$HOME/.config/.jira/.config.yml}"
if [[ ! -f "$JIRA_CONFIG_FILE" ]]; then
    echo -e "${YELLOW}JIRA CLI is not configured. Initializing...${NC}"

    # Validate required environment variables for non-interactive init
    if [[ -z "$JIRA_API_TOKEN" ]]; then
        echo -e "${RED}Error: JIRA_API_TOKEN environment variable is required${NC}"
        echo ""
        echo "Please set the following environment variables:"
        echo "  export JIRA_API_TOKEN=\"your-personal-access-token\""
        echo "  export JIRA_AUTH_TYPE=\"bearer\""
        echo ""
        echo "Or run 'jira init' manually to configure interactively."
        exit 1
    fi

    # Set defaults for jira init
    JIRA_SERVER="${JIRA_SERVER:-$DEFAULT_JIRA_SERVER}"
    JIRA_INSTALLATION="${JIRA_INSTALLATION:-Local}"
    JIRA_LOGIN="${JIRA_LOGIN:-${JIRA_USER:-}}"
    JIRA_AUTH_TYPE="${JIRA_AUTH_TYPE:-bearer}"
    # Set board to "None" if not specified (empty string causes interactive prompt)
    JIRA_BOARD="${JIRA_BOARD:-None}"

    echo -e "${BLUE}Initializing jira-cli with:${NC}"
    echo -e "  Server: $JIRA_SERVER"
    echo -e "  Installation: $JIRA_INSTALLATION"
    echo -e "  Auth Type: $JIRA_AUTH_TYPE"
    echo -e "  Project: $JIRA_PROJECT"
    echo -e "  Board: $JIRA_BOARD"
    echo ""

    # Run jira init non-interactively
    if jira init \
        --installation "$JIRA_INSTALLATION" \
        --server "$JIRA_SERVER" \
        --login "$JIRA_LOGIN" \
        --auth-type "$JIRA_AUTH_TYPE" \
        --project "$JIRA_PROJECT" \
        --board "$JIRA_BOARD" \
        --force; then
        echo -e "${GREEN}✓${NC} JIRA CLI initialized successfully"
    else
        echo -e "${RED}✗${NC} Failed to initialize JIRA CLI"
        echo ""
        echo "You can try running 'jira init' manually for interactive setup."
        exit 1
    fi
    echo ""
fi

# Extract application name from filename
# e.g., data/acm-215-compliance.csv -> acm-215
#       data/discovery-operator-mce-29-compliance.csv -> mce-29
# Pattern: Extract the last occurrence of (acm|mce)-<digits> from the filename
APP_NAME=$(basename "$COMPLIANCE_FILE" | sed 's/-compliance\.csv$//' | grep -oE '(acm|mce)-[0-9]+$' || basename "$COMPLIANCE_FILE" | sed 's/-compliance\.csv$//')
echo -e "${BLUE}Processing compliance data for application: $APP_NAME${NC}"

# Function to derive JIRA "Affects Version/s" from APP_NAME
# Format: acm-215 -> "ACM 2.15.0", mce-29 -> "MCE 2.9.0"
get_affects_version() {
    local app_name="$1"

    # Extract product (acm/mce) and version number
    local product=$(echo "$app_name" | cut -d'-' -f1 | tr '[:lower:]' '[:upper:]')
    local version_num=$(echo "$app_name" | cut -d'-' -f2)

    # Convert version number: 215 -> 2.15.0, 29 -> 2.9.0
    if [[ ${#version_num} -eq 3 ]]; then
        # Three digits: XYZ -> X.YZ.0
        local major="${version_num:0:1}"
        local minor="${version_num:1:2}"
        echo "${product} ${major}.${minor}.0"
    elif [[ ${#version_num} -eq 2 ]]; then
        # Two digits: XY -> X.Y.0
        local major="${version_num:0:1}"
        local minor="${version_num:1:1}"
        echo "${product} ${major}.${minor}.0"
    else
        # Unsupported format, return empty
        echo ""
    fi
}

AFFECTS_VERSION=$(get_affects_version "$APP_NAME")
if [[ -n "$AFFECTS_VERSION" ]]; then
    echo -e "${BLUE}Affects Version:${NC} $AFFECTS_VERSION"
fi

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: jq is required but not installed${NC}"
    echo "Install with: brew install jq (macOS) or apt-get install jq (Linux)"
    exit 1
fi

# Function to get JIRA server URL from configuration
get_jira_server_url() {
    local jira_config="${JIRA_CONFIG_FILE:-$HOME/.config/.jira/.config.yml}"
    local url=""

    if [[ -f "$jira_config" ]]; then
        url=$(grep "^[[:space:]]*server:" "$jira_config" | awk '{print $2}' | tr -d '"' 2>/dev/null || echo "")
    fi

    echo "${url:-$DEFAULT_JIRA_SERVER}"
}

# Function to build issue description with compliance details
build_issue_description() {
    local component_name="$1"
    local scan_time="$2"
    local promoted_time="$3"
    local promotion_status="$4"
    local hermetic_status="$5"
    local ec_status="$6"
    local multiarch_status="$7"
    local push_status="$8"
    local push_pipelinerun_url="$9"
    local ec_pipelinerun_url="${10}"

    # Build compliance status table using common helper
    local compliance_table=$(build_compliance_status_table "$promotion_status" "$promoted_time" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status")

    # Build action items using common helper
    local action_items=$(build_action_items "$promotion_status" "$promoted_time" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status")

    local description="h2. Component Compliance Failure

*Component:* \`$component_name\`
*Application:* \`$APP_NAME\`
*Scan Time:* $scan_time
*Image Build Time:* $promoted_time

h3. Compliance Status

$compliance_table

h3. Required Actions

$action_items"

    description+="
h3. Pipeline Run Links
"

    # Add push pipelinerun link if available
    if [[ -n "$push_pipelinerun_url" && "$push_pipelinerun_url" != "N/A" && "$push_pipelinerun_url" != "null" ]]; then
        description+="
* [Build Pipeline Run|$push_pipelinerun_url]"
    fi

    # Add EC pipelinerun link if available
    if [[ -n "$ec_pipelinerun_url" && "$ec_pipelinerun_url" != "N/A" && "$ec_pipelinerun_url" != "null" ]]; then
        description+="
* [Enterprise Contract Pipeline Run|$ec_pipelinerun_url]"
    fi

    echo "$description"
}

# Function to get all JIRA component names for a component (handles multi-squad components)
# Only returns jira-component field values, does not fall back to name field
get_component_squads() {
    local component_name="$1"
    local config_file="$SCRIPT_DIR/component-squad.yaml"

    if [[ ! -f "$config_file" ]]; then
        echo ""
        return
    fi

    # Strip version suffix (e.g., -210, -215, -27, -29) from component name
    # Pattern: remove trailing dash followed by digits
    local base_component_name=$(echo "$component_name" | sed 's/-[0-9][0-9]*$//')

    # Search through all squads to find which ones contain this component
    # Try exact match first, then try base name without version suffix
    # Only return jira-component field (do not fall back to name field)
    local jira_components=$(yq ".squads | to_entries | .[] | select(.value.components[] == \"$component_name\") | .value[\"jira-component\"]" "$config_file" 2>/dev/null)

    if [[ -z "$jira_components" && "$base_component_name" != "$component_name" ]]; then
        jira_components=$(yq ".squads | to_entries | .[] | select(.value.components[] == \"$base_component_name\") | .value[\"jira-component\"]" "$config_file" 2>/dev/null)
    fi

    # Filter out empty/null values and return all JIRA component names (one per line)
    echo "$jira_components" | grep -v '^$' | grep -v '^null$'
}

# Function to determine compliance-specific labels based on failure types
get_compliance_labels() {
    local promotion_status="$1"
    local promoted_time="$2"
    local hermetic_status="$3"
    local ec_status="$4"
    local multiarch_status="$5"
    local push_status="$6"

    local specific_labels=""

    # Image promotion failures or stale images
    if [[ "$promotion_status" =~ ($STATUS_FAILED|$STATUS_IMAGE_PULL_FAILURE|$STATUS_INSPECTION_FAILURE|$STATUS_DIGEST_FAILURE) ]]; then
        specific_labels+="image-promotion-failure,"
    elif [[ "$promotion_status" == "$STATUS_SUCCESSFUL" ]] && is_image_stale "$promoted_time"; then
        specific_labels+="image-stale-failure,"
    fi

    # Hermetic builds
    if [[ "$hermetic_status" == "$STATUS_NOT_ENABLED" ]]; then
        specific_labels+="hermetic-builds-failure,"
    fi

    # Enterprise Contract
    if [[ "$ec_status" == "$STATUS_NOT_COMPLIANT" ]]; then
        specific_labels+="enterprise-contract-failure,"
    fi

    # Push failures (separate from general EC failures)
    if [[ "$ec_status" == "$STATUS_PUSH_FAILURE" ]] || [[ "$push_status" == "$STATUS_FAILED" ]]; then
        specific_labels+="push-failure,"
    fi

    # Multiarch support
    if [[ "$multiarch_status" == "$STATUS_NOT_ENABLED" ]]; then
        specific_labels+="multiarch-support-failure,"
    fi

    # Remove trailing comma
    specific_labels="${specific_labels%,}"

    echo "$specific_labels"
}

# Function to create JIRA issue
create_jira_issue() {
    local component_name="$1"
    local scan_time="$2"
    local promoted_time="$3"
    local promotion_status="$4"
    local hermetic_status="$5"
    local ec_status="$6"
    local multiarch_status="$7"
    local push_status="$8"
    local push_pipelinerun_url="$9"
    local ec_pipelinerun_url="${10}"

    # Build description using helper function
    local description=$(build_issue_description "$component_name" "$scan_time" "$promoted_time" "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status" "$push_pipelinerun_url" "$ec_pipelinerun_url")

    # Build summary
    local summary="[$APP_NAME] $component_name - Konflux compliance failure"

    # Check for duplicates if requested
    if [[ "$SKIP_DUPLICATES" == true ]]; then
        local jql="project=$JIRA_PROJECT AND summary~\"$component_name\" AND labels=konflux AND labels=compliance AND labels=auto-created AND status NOT IN (Closed,Done,Resolved)"

        # Use jira-cli to search for existing issues
        local existing_issues=$(jira issue list --jql "$jql" --plain --no-headers --columns KEY 2>/dev/null || echo "")

        if [[ -n "$existing_issues" ]]; then
            local existing_key=$(echo "$existing_issues" | head -n 1 | awk '{print $1}' | xargs)
            echo -e "${YELLOW}⊘${NC} Found existing issue $existing_key for $component_name - adding update comment" >&2

            # Add update comment with latest scan results
            if update_existing_issue "$existing_key" "$component_name" "$scan_time" "$promoted_time" "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status" "$push_pipelinerun_url" "$ec_pipelinerun_url"; then
                echo "UPDATED:$existing_key"  # Output with UPDATED prefix for tracking
                return 0
            else
                # Failed to update, but we still don't want to create a duplicate
                echo "FAILED_UPDATE:$existing_key"  # Output with FAILED_UPDATE prefix for tracking
                return 1
            fi
        fi
    fi

    # Create a temporary file for the description
    local desc_file=$(mktemp)
    echo "$description" > "$desc_file"

    # Build jira-cli command arguments
    local jira_cmd_args=(
        "issue" "create"
        "--project" "$JIRA_PROJECT"
        "--type" "$ISSUE_TYPE"
        "--priority" "$PRIORITY"
        "--summary" "$summary"
        "--template" "$desc_file"
        "--custom" "activity-type=$JIRA_ACTIVITY_TYPE"
        "--custom" "severity=$JIRA_SEVERITY"
        "--no-input"
    )

    # Add Affects Version/s if available
    if [[ -n "$AFFECTS_VERSION" ]]; then
        jira_cmd_args+=("--affects-version" "$AFFECTS_VERSION")
    fi

    # Add labels (base labels + compliance-specific labels)
    local compliance_specific_labels=$(get_compliance_labels "$promotion_status" "$promoted_time" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status")
    local all_labels="$LABELS"
    if [[ -n "$compliance_specific_labels" ]]; then
        all_labels="$all_labels,$compliance_specific_labels"
    fi

    if [[ -n "$all_labels" ]]; then
        IFS=',' read -ra LABEL_ARRAY <<< "$all_labels"
        for label in "${LABEL_ARRAY[@]}"; do
            label=$(echo "$label" | xargs)  # trim whitespace
            if [[ -n "$label" ]]; then
                jira_cmd_args+=("--label" "$label")
            fi
        done
    fi

    # Add component(s) - use squad name(s) from component-squad.yaml unless overridden
    if [[ -n "$COMPONENT" ]]; then
        # User specified component override - use it
        jira_cmd_args+=("--component" "$COMPONENT")
    else
        # Look up squad name(s) for this component
        local squad_names=$(get_component_squads "$component_name")
        if [[ -n "$squad_names" ]]; then
            # Add each squad as a separate JIRA component
            while IFS= read -r squad_name; do
                if [[ -n "$squad_name" ]]; then
                    jira_cmd_args+=("--component" "$squad_name")
                fi
            done <<< "$squad_names"
        fi
    fi

    # Handle dry-run mode - show what would be created (after building the command)
    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}[DRY RUN]${NC} Would create issue:" >&2
        echo -e "${BLUE}Summary:${NC} $summary" >&2
        echo -e "${BLUE}Project:${NC} $JIRA_PROJECT" >&2
        echo -e "${BLUE}Type:${NC} $ISSUE_TYPE" >&2
        echo -e "${BLUE}Priority:${NC} $PRIORITY" >&2

        # Show all labels (base + compliance-specific)
        local compliance_specific_labels=$(get_compliance_labels "$promotion_status" "$promoted_time" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status")
        local all_labels="$LABELS"
        if [[ -n "$compliance_specific_labels" ]]; then
            all_labels="$all_labels,$compliance_specific_labels"
        fi
        echo -e "${BLUE}Labels:${NC} $all_labels" >&2

        if [[ -n "$AFFECTS_VERSION" ]]; then
            echo -e "${BLUE}Affects Version/s:${NC} $AFFECTS_VERSION" >&2
        fi

        # Show component(s) if any
        local components_list=""
        for arg_idx in "${!jira_cmd_args[@]}"; do
            if [[ "${jira_cmd_args[$arg_idx]}" == "--component" ]]; then
                local next_idx=$((arg_idx + 1))
                if [[ -n "$components_list" ]]; then
                    components_list+=", "
                fi
                components_list+="${jira_cmd_args[$next_idx]}"
            fi
        done
        if [[ -n "$components_list" ]]; then
            echo -e "${BLUE}Component(s):${NC} $components_list" >&2
        fi

        # If debug is enabled, show the full jira-cli command
        if [[ "$DEBUG" == true ]]; then
            echo "" >&2
            echo -e "${BLUE}Command:${NC}" >&2
            echo -n "jira" >&2
            for arg in "${jira_cmd_args[@]}"; do
                if [[ "$arg" =~ [[:space:]] ]]; then
                    echo -n " \"$arg\"" >&2
                else
                    echo -n " $arg" >&2
                fi
            done
            echo "" >&2
            echo "" >&2
            echo -e "${BLUE}Description content:${NC}" >&2
            cat "$desc_file" >&2
        fi

        echo "" >&2
        rm -f "$desc_file"
        echo "DRY-RUN-ISSUE"  # Output placeholder for dry-run mode (stdout for capture)
        return 0
    fi

    # Create the issue using jira-cli
    # If debug is enabled, print the command being executed
    if [[ "$DEBUG" == true ]]; then
        debug_echo "${BLUE}Executing command:${NC}"
        debug_echo -n "jira"
        for arg in "${jira_cmd_args[@]}"; do
            if [[ "$arg" =~ [[:space:]] ]]; then
                debug_echo -n " \"$arg\""
            else
                debug_echo -n " $arg"
            fi
        done
        debug_echo ""
        debug_echo ""
        debug_echo "${BLUE}Description content:${NC}"
        debug_echo "$(cat "$desc_file")"
        debug_echo ""
    fi

    local output
    output=$(jira "${jira_cmd_args[@]}" 2>&1)
    local exit_code=$?

    # Clean up temp file
    rm -f "$desc_file"

    # Extract issue key from output
    # jira-cli typically outputs: "Issue created: PROJECT-123" or similar
    local issue_key=$(echo "$output" | grep -oE '[A-Z]+-[0-9]+' | head -n 1)

    if [[ $exit_code -eq 0 && -n "$issue_key" ]]; then
        # Get JIRA URL from jira-cli config
        local jira_url=$(get_jira_server_url)
        echo -e "${GREEN}✓${NC} Created issue $issue_key for $component_name: $jira_url/browse/$issue_key" >&2
        echo "$issue_key"  # Output issue key for capture
        return 0
    else
        echo -e "${RED}✗${NC} Failed to create issue for $component_name: $output" >&2
        return 1
    fi
}

# Function to validate CSV line format
# Expected format: at least 9 required fields (component,scan_time,promoted_time,promotion,hermetic,ec,multiarch,push,push_url,ec_url)
validate_csv_line() {
    local line="$1"
    local line_number="$2"
    local min_required_fields=9

    # Skip empty lines
    if [[ -z "$line" ]]; then
        return 0
    fi

    # Count fields
    local field_count=$(echo "$line" | awk -F',' '{print NF}')

    if [[ "$field_count" -lt "$min_required_fields" ]]; then
        echo -e "${RED}ERROR:${NC} Invalid CSV format at line $line_number" >&2
        echo -e "${RED}Expected at least $min_required_fields fields, got $field_count${NC}" >&2
        echo -e "${YELLOW}Line:${NC} $line" >&2
        return 1
    fi

    return 0
}

# Function to check if image build time is stale (>2 weeks)
is_image_stale() {
    local promoted_time="$1"

    # Check if promoted_time is a valid timestamp
    if [[ "$promoted_time" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2} ]]; then
        # Convert promoted_time to epoch seconds (handle both Z suffix and no suffix)
        local promoted_time_clean="${promoted_time%Z}"
        local promoted_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$promoted_time_clean" "+%s" 2>/dev/null)

        if [[ -n "$promoted_epoch" ]]; then
            local current_epoch=$(date +%s)
            local age_seconds=$((current_epoch - promoted_epoch))
            local two_weeks_seconds=$((14 * 24 * 60 * 60))  # 2 weeks in seconds

            if [[ $age_seconds -gt $two_weeks_seconds ]]; then
                return 0  # true - is stale
            fi
        fi
    fi

    return 1  # false - not stale
}

# Function to check if a component is non-compliant
is_non_compliant() {
    local promotion_status="$1"
    local hermetic_status="$2"
    local ec_status="$3"
    local multiarch_status="$4"
    local push_status="$5"
    local promoted_time="$6"

    # Check for promotion failures
    if [[ "$promotion_status" =~ ($STATUS_FAILED|$STATUS_IMAGE_PULL_FAILURE|$STATUS_INSPECTION_FAILURE|$STATUS_DIGEST_FAILURE) ]]; then
        return 0  # true - is non-compliant
    fi

    # Check if successful promotion but image is stale (>2 weeks) - treat as non-compliant
    if [[ "$promotion_status" == "$STATUS_SUCCESSFUL" ]] && is_image_stale "$promoted_time"; then
        return 0  # true - is non-compliant (stale image)
    fi

    # Check for other failure conditions
    if [[ "$hermetic_status" == "$STATUS_NOT_ENABLED" ]] || \
       [[ "$ec_status" =~ ($STATUS_NOT_COMPLIANT|$STATUS_PUSH_FAILURE) ]] || \
       [[ "$multiarch_status" == "$STATUS_NOT_ENABLED" ]] || \
       [[ "$push_status" == "$STATUS_FAILED" ]]; then
        return 0  # true - is non-compliant
    fi

    return 1  # false - is compliant
}

# Function to format Image Promotion status with timestamp and staleness check
# Returns: "Successful(timestamp)", "Stale(timestamp)" if >2 weeks old, or original status
format_promotion_status() {
    local promotion_status="$1"
    local promoted_time="$2"

    # If promotion was successful, check if image is stale (>2 weeks)
    if [[ "$promotion_status" == "$STATUS_SUCCESSFUL" ]]; then
        if is_image_stale "$promoted_time"; then
            echo "Stale($promoted_time)"
        else
            echo "Successful($promoted_time)"
        fi
        return
    fi

    # For all other statuses (Failed, IMAGE_PULL_FAILURE, etc.), return as-is
    echo "$promotion_status"
}

# Function to build compliance status table (common for all JIRA issue operations)
build_compliance_status_table() {
    local promotion_status="$1"
    local promoted_time="$2"
    local hermetic_status="$3"
    local ec_status="$4"
    local multiarch_status="$5"
    local push_status="$6"

    # Format promotion status with timestamp and staleness check
    local formatted_promotion_status=$(format_promotion_status "$promotion_status" "$promoted_time")

    local table="||Check||Status||
|Image Promotion|$formatted_promotion_status|
|Hermetic Builds|$hermetic_status|
|Enterprise Contract|$ec_status|
|Multiarch Support|$multiarch_status|
|Push Pipeline|$push_status|"

    echo "$table"
}

# Function to build action items based on compliance failures (common for all JIRA issue operations)
build_action_items() {
    local promotion_status="$1"
    local promoted_time="$2"
    local hermetic_status="$3"
    local ec_status="$4"
    local multiarch_status="$5"
    local push_status="$6"

    local actions=""

    # Promotion failures or stale images
    if [[ "$promotion_status" =~ ($STATUS_FAILED|$STATUS_IMAGE_PULL_FAILURE|$STATUS_INSPECTION_FAILURE|$STATUS_DIGEST_FAILURE) ]]; then
        actions+="* Fix image promotion issues - component has no valid promoted image
"
    elif [[ "$promotion_status" == "$STATUS_SUCCESSFUL" ]] && is_image_stale "$promoted_time"; then
        actions+="* Rebuild component - image is over 2 weeks old and needs to be updated
"
    fi

    # Hermetic builds
    if [[ "$hermetic_status" == "$STATUS_NOT_ENABLED" ]]; then
        actions+="* Enable hermetic builds:
** Set \`hermetic: true\` in .tekton pipeline YAML
** Set \`build-source-image: true\` in .tekton pipeline YAML
** Add \`prefetch-input\` configuration or vendor dependencies
"
    fi

    # Enterprise Contract
    if [[ "$ec_status" == "$STATUS_NOT_COMPLIANT" ]]; then
        actions+="* Fix Enterprise Contract violations - check Konflux pipeline logs
"
    fi

    if [[ "$ec_status" == "$STATUS_PUSH_FAILURE" ]]; then
        actions+="* Fix pipeline push failures - component build is failing
"
    fi

    # Multiarch support
    if [[ "$multiarch_status" == "$STATUS_NOT_ENABLED" ]]; then
        actions+="* Enable multiarch support:
** Add \`build-platforms\` parameter with 4 platforms: [linux/amd64, linux/arm64, linux/ppc64le, linux/s390x]
"
    fi

    # Push pipeline
    if [[ "$push_status" == "$STATUS_FAILED" ]]; then
        actions+="* Fix push pipeline failures - check the build pipeline run logs for errors
"
    fi

    echo "$actions"
}

# Function to extract component name from JIRA summary
# Summary format: "[app-name] component-name - Konflux compliance failure"
extract_component_from_summary() {
    local summary="$1"

    # Extract component name between "] " and " - Konflux"
    # e.g., "[acm-215] cluster-curator-controller-215 - Konflux compliance failure"
    #       -> "cluster-curator-controller-215"
    echo "$summary" | sed -n 's/.*\] \(.*\) - Konflux.*/\1/p'
}

# Function to add update comment to existing JIRA issue with latest scan results
update_existing_issue() {
    local issue_key="$1"
    local component_name="$2"
    local scan_time="$3"
    local promoted_time="$4"
    local promotion_status="$5"
    local hermetic_status="$6"
    local ec_status="$7"
    local multiarch_status="$8"
    local push_status="$9"
    local push_pipelinerun_url="${10}"
    local ec_pipelinerun_url="${11}"

    # Build compliance status table using common helper
    local compliance_table=$(build_compliance_status_table "$promotion_status" "$promoted_time" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status")

    # Build action items using common helper
    local action_items=$(build_action_items "$promotion_status" "$promoted_time" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status")

    # Build update comment with latest scan results
    local comment="h2. Updated Compliance Scan Results

Component \`$component_name\` remains non-compliant. Latest scan results below.

h3. Current Compliance Status

$compliance_table

*Scan Time:* $scan_time
*Image Build Time:* $promoted_time

h3. Required Actions

$action_items"

    # Add pipeline run links if available
    if [[ -n "$push_pipelinerun_url" && "$push_pipelinerun_url" != "N/A" && "$push_pipelinerun_url" != "null" ]] || \
       [[ -n "$ec_pipelinerun_url" && "$ec_pipelinerun_url" != "N/A" && "$ec_pipelinerun_url" != "null" ]]; then
        comment+="

h3. Latest Pipeline Run Links
"

        if [[ -n "$push_pipelinerun_url" && "$push_pipelinerun_url" != "N/A" && "$push_pipelinerun_url" != "null" ]]; then
            comment+="
* [Build Pipeline Run|$push_pipelinerun_url]"
        fi

        if [[ -n "$ec_pipelinerun_url" && "$ec_pipelinerun_url" != "N/A" && "$ec_pipelinerun_url" != "null" ]]; then
            comment+="
* [Enterprise Contract Pipeline Run|$ec_pipelinerun_url]"
        fi
    fi

    # Get compliance-specific labels that should be added
    local compliance_specific_labels=$(get_compliance_labels "$promotion_status" "$promoted_time" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status")

    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}[DRY RUN]${NC} Would add update comment to issue $issue_key for component $component_name" >&2
        if [[ -n "$compliance_specific_labels" ]]; then
            echo -e "${YELLOW}[DRY RUN]${NC} Would add labels: $compliance_specific_labels" >&2
        fi
        if [[ "$DEBUG" == true ]]; then
            echo -e "${BLUE}Comment:${NC}" >&2
            echo "$comment" >&2
            echo "" >&2
        fi
        return 0
    fi

    # Add comment to issue
    local comment_file=$(mktemp)
    echo "$comment" > "$comment_file"

    if [[ "$DEBUG" == true ]]; then
        debug_echo "${BLUE}Adding update comment to $issue_key${NC}"
        debug_echo "$(cat "$comment_file")"
    fi

    jira issue comment add "$issue_key" --template "$comment_file" 2>&1 > /dev/null
    local comment_exit_code=$?
    rm -f "$comment_file"

    if [[ $comment_exit_code -ne 0 ]]; then
        echo -e "${RED}✗${NC} Failed to add comment to $issue_key" >&2
        return 1
    fi

    # Add compliance-specific labels if any
    if [[ -n "$compliance_specific_labels" ]]; then
        # Get current labels from the issue
        local current_labels=$(jira issue view "$issue_key" --plain 2>/dev/null | grep "^Labels:" | sed 's/^Labels:[[:space:]]*//' | tr ',' '\n' | xargs)

        # Build label arguments for labels that don't already exist
        local -a label_args=()
        IFS=',' read -ra NEW_LABELS <<< "$compliance_specific_labels"
        for new_label in "${NEW_LABELS[@]}"; do
            new_label=$(echo "$new_label" | xargs)
            if [[ -n "$new_label" ]] && ! echo "$current_labels" | grep -qw "$new_label"; then
                label_args+=("--label" "$new_label")
            fi
        done

        # Add new labels if any
        if [[ ${#label_args[@]} -gt 0 ]]; then
            if jira issue edit "$issue_key" "${label_args[@]}" --no-input 2>&1 > /dev/null; then
                echo -e "${GREEN}✓${NC} Updated issue $issue_key with latest scan results and added ${#label_args[@]} new label(s)" >&2
            else
                echo -e "${YELLOW}⚠${NC} Updated issue $issue_key but failed to add labels" >&2
            fi
        else
            echo -e "${GREEN}✓${NC} Updated issue $issue_key with latest scan results" >&2
        fi
    else
        echo -e "${GREEN}✓${NC} Updated issue $issue_key with latest scan results" >&2
    fi

    return 0
}

# Function to close JIRA issue with resolution comment
close_jira_issue() {
    local issue_key="$1"
    local component_name="$2"
    local scan_time="$3"
    local promoted_time="$4"
    local promotion_status="$5"
    local hermetic_status="$6"
    local ec_status="$7"
    local multiarch_status="$8"
    local push_status="$9"

    # Build compliance status table using common helper
    local compliance_table=$(build_compliance_status_table "$promotion_status" "$promoted_time" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status")

    # Build resolution comment
    local comment="Component \`$component_name\` is now compliant based on the latest compliance scan.

h3. Compliance Status (Latest Scan)

$compliance_table

*Scan Time:* $scan_time
*Image Build Time:* $promoted_time

All compliance checks are now passing. Auto-closing this issue."

    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}[DRY RUN]${NC} Would close issue $issue_key for component $component_name" >&2
        if [[ "$DEBUG" == true ]]; then
            echo -e "${BLUE}Comment:${NC}" >&2
            echo "$comment" >&2
            echo "" >&2
        fi
        return 0
    fi

    # Add comment to issue
    local comment_file=$(mktemp)
    echo "$comment" > "$comment_file"

    if [[ "$DEBUG" == true ]]; then
        debug_echo "${BLUE}Adding comment to $issue_key${NC}"
        debug_echo "$(cat "$comment_file")"
    fi

    jira issue comment add "$issue_key" --template "$comment_file" 2>&1 > /dev/null
    local comment_exit_code=$?
    rm -f "$comment_file"

    if [[ $comment_exit_code -ne 0 ]]; then
        echo -e "${RED}✗${NC} Failed to add comment to $issue_key" >&2
        return 1
    fi

    # Close the issue (transition to Closed state)
    if jira issue move "$issue_key" "Closed" 2>&1 > /dev/null; then
        echo -e "${GREEN}✓${NC} Closed issue $issue_key for component $component_name" >&2
        return 0
    else
        echo -e "${RED}✗${NC} Failed to close issue $issue_key (transition failed)" >&2
        return 1
    fi
}

# Function to get open JIRA issues and auto-close resolved ones
auto_close_resolved_issues() {
    local project="$1"
    local labels="$2"

    # Build JQL query
    local label_filters=""
    IFS=',' read -ra LABEL_ARRAY <<< "$labels"
    for label in "${LABEL_ARRAY[@]}"; do
        label=$(echo "$label" | xargs)  # trim whitespace
        if [[ -n "$label_filters" ]]; then
            label_filters+=" AND "
        fi
        label_filters+="labels=$label"
    done

    local jql="project=$project AND $label_filters AND status NOT IN (Closed,Done,Resolved)"

    debug_echo "${BLUE}JQL Query: $jql${NC}"

    # Query JIRA for open issues
    # Format: KEY<tab>SUMMARY
    local open_issues=$(jira issue list --jql "$jql" --plain --no-headers --columns KEY,SUMMARY 2>/dev/null || echo "")

    if [[ -z "$open_issues" ]]; then
        echo -e "${BLUE}No open issues found to auto-close${NC}"
        return 0
    fi

    local closed_count=0
    local skipped_count=0
    local failed_count=0

    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}Auto-closing resolved issues${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    while IFS=$'\t' read -r issue_key summary; do
        # Extract component name from summary
        local component_name=$(extract_component_from_summary "$summary")

        if [[ -z "$component_name" ]]; then
            echo -e "${YELLOW}⊘${NC} Skipping $issue_key - could not extract component name from summary"
            skipped_count=$((skipped_count + 1))
            continue
        fi

        debug_echo "${BLUE}Checking $issue_key: $component_name${NC}"

        # Check if component exists in COMPLIANCE_STATUS map
        if [[ ! -v COMPLIANCE_STATUS["$component_name"] ]]; then
            echo -e "${YELLOW}⊘${NC} Skipping $issue_key - component $component_name not found in compliance CSV"
            skipped_count=$((skipped_count + 1))
            continue
        fi

        # Check if component is now compliant
        if [[ "${COMPLIANCE_STATUS[$component_name]}" == "compliant" ]]; then
            echo -e "${BLUE}Processing:${NC} $component_name ($issue_key)"

            # Parse compliance details
            IFS=',' read -r scan_time promoted_time promotion_status hermetic_status ec_status multiarch_status push_status <<< "${COMPLIANCE_DETAILS[$component_name]}"

            if close_jira_issue "$issue_key" "$component_name" "$scan_time" "$promoted_time" "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status"; then
                closed_count=$((closed_count + 1))
            else
                failed_count=$((failed_count + 1))
            fi
        else
            debug_echo "${YELLOW}⊘${NC} Skipping $issue_key - component $component_name is still non-compliant"
            skipped_count=$((skipped_count + 1))
        fi

    done <<< "$open_issues"

    # Print auto-close summary
    echo ""
    echo -e "${BLUE}Auto-close Summary:${NC}"
    echo -e "${GREEN}Issues closed:${NC} $closed_count"
    echo -e "${YELLOW}Issues skipped:${NC} $skipped_count"
    echo -e "${RED}Failed:${NC} $failed_count"
    echo ""
}

# Main processing
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Konflux Compliance JIRA Issue Creator${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Project:${NC} $JIRA_PROJECT"
echo -e "${BLUE}Application:${NC} $APP_NAME"
echo -e "${BLUE}JIRA Auth Type:${NC} ${JIRA_AUTH_TYPE:-not set}"
echo ""

# Read compliance data from CSV
# The CSV format is: component_name,build_time,promotion_status,hermetic_status,ec_status,multiarch_status,push_status,push_pipelinerun_url,ec_pipelinerun_url
created_count=0
updated_count=0
skipped_count=0
failed_count=0
total_count=0

declare -a created_issues
declare -a updated_issues
declare -a created_issues_json

# For auto-close feature: track compliance status
declare -A COMPLIANCE_STATUS
declare -A COMPLIANCE_DETAILS

echo -e "${BLUE}Starting to process CSV file: $COMPLIANCE_FILE${NC}" >&2
echo -e "${BLUE}File exists: $(test -f "$COMPLIANCE_FILE" && echo yes || echo no)${NC}" >&2
echo -e "${BLUE}File content (first 3 lines):${NC}" >&2
head -3 "$COMPLIANCE_FILE" >&2
echo "" >&2

while IFS=',' read -r component_name scan_time promoted_time promotion_status hermetic_status ec_status multiarch_status push_status push_pipelinerun_url ec_pipelinerun_url; do
    total_count=$((total_count + 1))

    # Read the original line for validation
    IFS= read -r original_line < <(sed -n "${total_count}p" "$COMPLIANCE_FILE")

    # Validate CSV line format (allows optional trailing fields)
    if ! validate_csv_line "$original_line" "$total_count"; then
        failed_count=$((failed_count + 1))
        continue
    fi

    echo -e "${BLUE}DEBUG: Read line $total_count: component=$component_name${NC}" >&2

    # Skip empty lines and header
    if [[ -z "$component_name" || "$component_name" == "Konflux Component" ]]; then
        continue
    fi

    # Track compliance status for auto-close feature
    if is_non_compliant "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status" "$promoted_time"; then
        COMPLIANCE_STATUS["$component_name"]="non-compliant"
    else
        COMPLIANCE_STATUS["$component_name"]="compliant"
        # Store details for auto-close comment
        COMPLIANCE_DETAILS["$component_name"]="$scan_time,$promoted_time,$promotion_status,$hermetic_status,$ec_status,$multiarch_status,$push_status"
    fi

    # Check if component is non-compliant
    if is_non_compliant "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status" "$promoted_time"; then
        echo -e "${BLUE}Processing:${NC} $component_name"

        issue_output=$(create_jira_issue "$component_name" "$scan_time" "$promoted_time" "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_status" "$push_pipelinerun_url" "$ec_pipelinerun_url")
        create_exit_code=$?

        if [[ $create_exit_code -eq 0 ]]; then
            # Extract the issue key (last line of output) and trim whitespace
            issue_key=$(echo "$issue_output" | tail -n 1 | xargs)

            # Check if this was an update or a new creation
            if [[ "$issue_key" == UPDATED:* ]]; then
                # This was an existing issue that we updated
                updated_count=$((updated_count + 1))
                actual_key="${issue_key#UPDATED:}"
                updated_issues+=("$component_name:$actual_key")
                if [[ -n "$OUTPUT_JSON" ]]; then
                    created_issues_json+=("{\"component\": \"$component_name\", \"status\": \"updated\", \"issue_key\": \"$actual_key\"}")
                fi
            else
                # This was a new issue creation
                created_count=$((created_count + 1))
                created_issues+=("$component_name:$issue_key")
                if [[ -n "$OUTPUT_JSON" ]]; then
                    created_issues_json+=("{\"component\": \"$component_name\", \"status\": \"created\", \"issue_key\": \"$issue_key\"}")
                fi
            fi
        else
            failed_count=$((failed_count + 1))
        fi
    else
        echo -e "${GREEN}✓${NC} $component_name is compliant - skipping"
        skipped_count=$((skipped_count + 1))
    fi

done < "$COMPLIANCE_FILE"

# Auto-close resolved issues if requested
if [[ "$AUTO_CLOSE" == true ]]; then
    auto_close_resolved_issues "$JIRA_PROJECT" "$LABELS"
fi

# Save output JSON if requested
if [[ -n "$OUTPUT_JSON" && "${created_count}" -gt 0 ]]; then
    printf "[%s]\n" "$(IFS=,; echo "${created_issues_json[*]}")" | jq '.' > "$OUTPUT_JSON"
    echo -e "${GREEN}✓${NC} Saved created issues to $OUTPUT_JSON"
fi

# Print summary
echo ""
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Summary${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "Total components processed: $total_count"
echo -e "${GREEN}Compliant (skipped):${NC} $skipped_count"
echo -e "${GREEN}Issues created:${NC} $created_count"
echo -e "${YELLOW}Issues updated:${NC} $updated_count"
echo -e "${RED}Failed:${NC} $failed_count"

# Print list of created issues with URLs
if [[ "${created_count}" -gt 0 ]]; then
    echo ""
    echo -e "${BLUE}Created Issues:${NC}"
    # Get JIRA URL from jira-cli config
    jira_url=$(get_jira_server_url)
    for issue_info in "${created_issues[@]}"; do
        comp_name="${issue_info%%:*}"
        issue_key="${issue_info##*:}"
        # Trim any whitespace from issue key
        issue_key=$(echo "$issue_key" | xargs)
        echo -e "  • $comp_name: $jira_url/browse/$issue_key"
    done
fi

# Print list of updated issues with URLs
if [[ "${updated_count}" -gt 0 ]]; then
    echo ""
    echo -e "${BLUE}Updated Issues:${NC}"
    # Get JIRA URL from jira-cli config
    jira_url=$(get_jira_server_url)
    for issue_info in "${updated_issues[@]}"; do
        comp_name="${issue_info%%:*}"
        issue_key="${issue_info##*:}"
        # Trim any whitespace from issue key
        issue_key=$(echo "$issue_key" | xargs)
        echo -e "  • $comp_name: $jira_url/browse/$issue_key"
    done
fi

if [[ "$DRY_RUN" == true ]]; then
    echo ""
    echo -e "${YELLOW}This was a dry run. No issues were actually created.${NC}"
    echo -e "Remove --dry-run flag to create issues."
fi

exit 0
