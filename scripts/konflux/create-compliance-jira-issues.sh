#!/usr/bin/env bash

set -euo pipefail

# Script to create JIRA issues for non-compliant Konflux components
# Reads the compliance CSV file generated by compliance.sh and creates
# JIRA issues for components that have compliance failures

# Load environment variables from .env file if it exists
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/.env" ]]; then
    set -a  # automatically export all variables
    source "$SCRIPT_DIR/.env"
    set +a
fi

show_help() {
    cat << EOF
Usage: create-compliance-jira-issues.sh [OPTIONS] <compliance-csv-file>

Create JIRA issues for non-compliant components from compliance.sh output

ARGUMENTS:
    <compliance-csv-file>    Path to the compliance CSV file (e.g., data/acm-215-compliance.csv)

OPTIONS:
    --project PROJECT        JIRA project key (default: from JIRA_PROJECT env var or "ACM")
    --issue-type TYPE        JIRA issue type (default: "Bug")
    --priority PRIORITY      JIRA priority (default: "Critical")
    --component COMPONENT    JIRA component field (optional, overrides auto-detection from component-squad.yaml)
    --labels LABELS          Comma-separated labels (default: "konflux,compliance")
    --dry-run                Show what would be created without actually creating issues
    --skip-duplicates        Skip creating issues if similar ones already exist
    --output-json FILE       Save created issues to JSON file
    -h, --help               Show this help message

NOTE:
    The script automatically sets the JIRA Component/s field based on the squad mapping
    in component-squad.yaml. Each component is mapped to its squad name (e.g., "Server Foundation",
    "Install", "GRC", etc.). You can override this by using the --component option.

ENVIRONMENT VARIABLES:
    JIRA_PROJECT             JIRA project key (e.g., ACM, MCE)

PREREQUISITES:
    This script requires jira-cli (https://github.com/ankitpokhrel/jira-cli)

    Installation:
    # macOS (Homebrew)
    brew install ankitpokhrel/jira-cli/jira-cli

    # Linux
    curl -sL https://github.com/ankitpokhrel/jira-cli/releases/latest/download/jira_linux_amd64.tar.gz | tar xz
    sudo mv jira /usr/local/bin/

    Configuration:
    jira init
    # Follow the prompts to configure your JIRA instance

EXAMPLES:
    # First time setup
    jira init

    # Create issues with default settings
    export JIRA_PROJECT="ACM"
    ./create-compliance-jira-issues.sh data/acm-215-compliance.csv

    # Dry run to preview what would be created
    ./create-compliance-jira-issues.sh --dry-run data/acm-215-compliance.csv

    # Create issues with custom labels and priority
    ./create-compliance-jira-issues.sh --labels "konflux,compliance,urgent" --priority "Critical" data/acm-215-compliance.csv

    # Skip duplicates and save output
    ./create-compliance-jira-issues.sh --skip-duplicates --output-json issues.json data/acm-215-compliance.csv

CSV FORMAT:
    The compliance CSV file should have the following format (from compliance.sh):
    <component-name>,<build-timestamp>,<promotion-status>,<hermetic-status>,<ec-status>,<multiarch-status>,<pipelinerun-url>

    Each line represents one component with its compliance data.

EOF
}

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
JIRA_PROJECT="${JIRA_PROJECT:-ACM}"
ISSUE_TYPE="Bug"
PRIORITY="Critical"
COMPONENT=""
LABELS="konflux,compliance"
DRY_RUN=false
SKIP_DUPLICATES=false
OUTPUT_JSON=""
COMPLIANCE_FILE=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --project)
            JIRA_PROJECT="$2"
            shift 2
            ;;
        --issue-type)
            ISSUE_TYPE="$2"
            shift 2
            ;;
        --priority)
            PRIORITY="$2"
            shift 2
            ;;
        --component)
            COMPONENT="$2"
            shift 2
            ;;
        --labels)
            LABELS="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --skip-duplicates)
            SKIP_DUPLICATES=true
            shift
            ;;
        --output-json)
            OUTPUT_JSON="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "Unknown option: $1"
            echo ""
            show_help
            exit 1
            ;;
        *)
            if [[ -z "$COMPLIANCE_FILE" ]]; then
                COMPLIANCE_FILE="$1"
            else
                echo "Error: Multiple compliance files specified"
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate required parameters
if [[ -z "$COMPLIANCE_FILE" ]]; then
    echo -e "${RED}Error: Compliance CSV file is required${NC}"
    echo ""
    show_help
    exit 1
fi

if [[ ! -f "$COMPLIANCE_FILE" ]]; then
    echo -e "${RED}Error: Compliance file not found: $COMPLIANCE_FILE${NC}"
    exit 1
fi

# Check if jira-cli is installed
if ! command -v jira &> /dev/null; then
    echo -e "${RED}Error: jira-cli is required but not installed${NC}"
    echo ""
    echo "Install jira-cli from: https://github.com/ankitpokhrel/jira-cli"
    echo ""
    echo "macOS (Homebrew):"
    echo "  brew install ankitpokhrel/jira-cli/jira-cli"
    echo ""
    echo "Linux:"
    echo "  curl -sL https://github.com/ankitpokhrel/jira-cli/releases/latest/download/jira_linux_amd64.tar.gz | tar xz"
    echo "  sudo mv jira /usr/local/bin/"
    echo ""
    echo "After installation, run: jira init"
    exit 1
fi

# Extract application name from filename
# e.g., data/acm-215-compliance.csv -> acm-215
APP_NAME=$(basename "$COMPLIANCE_FILE" | sed 's/-compliance\.csv$//')
echo -e "${BLUE}Processing compliance data for application: $APP_NAME${NC}"

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: jq is required but not installed${NC}"
    echo "Install with: brew install jq (macOS) or apt-get install jq (Linux)"
    exit 1
fi

# Function to get squad name for a component
get_component_squad() {
    local component_name="$1"
    local config_file="$SCRIPT_DIR/component-squad.yaml"

    if [[ ! -f "$config_file" ]]; then
        echo ""
        return
    fi

    # Strip version suffix (e.g., -210, -215, -27, -29) from component name
    # Pattern: remove trailing dash followed by digits
    local base_component_name=$(echo "$component_name" | sed 's/-[0-9][0-9]*$//')

    # Search through all squads to find which one contains this component
    # Try exact match first, then try base name without version suffix
    local squad_name=$(yq ".squads | to_entries | .[] | select(.value.components[] == \"$component_name\") | .value.name" "$config_file" 2>/dev/null | head -n 1)

    if [[ -z "$squad_name" && "$base_component_name" != "$component_name" ]]; then
        squad_name=$(yq ".squads | to_entries | .[] | select(.value.components[] == \"$base_component_name\") | .value.name" "$config_file" 2>/dev/null | head -n 1)
    fi

    echo "$squad_name"
}

# Function to create JIRA issue
create_jira_issue() {
    local component_name="$1"
    local build_time="$2"
    local promotion_status="$3"
    local hermetic_status="$4"
    local ec_status="$5"
    local multiarch_status="$6"
    local push_pipelinerun_url="$7"
    local ec_pipelinerun_url="$8"

    # Build description with compliance details
    local description="h2. Component Compliance Failure

*Component:* \`$component_name\`
*Application:* \`$APP_NAME\`
*Build Time:* $build_time

h3. Compliance Status

||Check||Status||
|Image Promotion|$promotion_status|
|Hermetic Builds|$hermetic_status|
|Enterprise Contract|$ec_status|
|Multiarch Support|$multiarch_status|

h3. Required Actions
"

    # Add specific action items based on failures
    if [[ "$promotion_status" =~ (Failed|IMAGE_PULL_FAILURE|INSPECTION_FAILURE|DIGEST_FAILURE) ]]; then
        description+="* Fix image promotion issues - component has no valid promoted image
"
    fi

    if [[ "$hermetic_status" == "Not Enabled" ]]; then
        description+="* Enable hermetic builds:
** Set \`hermetic: true\` in .tekton pipeline YAML
** Set \`build-source-image: true\` in .tekton pipeline YAML
** Add \`prefetch-input\` configuration or vendor dependencies
"
    fi

    if [[ "$ec_status" == "Not Compliant" ]]; then
        description+="* Fix Enterprise Contract violations - check Konflux pipeline logs
"
    fi

    if [[ "$ec_status" == "Push Failure" ]]; then
        description+="* Fix pipeline push failures - component build is failing
"
    fi

    if [[ "$multiarch_status" == "Not Enabled" ]]; then
        description+="* Enable multiarch support:
** Add \`build-platforms\` parameter with 4 platforms: [linux/amd64, linux/arm64, linux/ppc64le, linux/s390x]
"
    fi

    description+="
h3. Pipeline Run Links
"

    # Add push pipelinerun link if available
    if [[ -n "$push_pipelinerun_url" && "$push_pipelinerun_url" != "N/A" && "$push_pipelinerun_url" != "null" ]]; then
        description+="
* [Build Pipeline Run|$push_pipelinerun_url]"
    fi

    # Add EC pipelinerun link if available
    if [[ -n "$ec_pipelinerun_url" && "$ec_pipelinerun_url" != "N/A" && "$ec_pipelinerun_url" != "null" ]]; then
        description+="
* [Enterprise Contract Pipeline Run|$ec_pipelinerun_url]"
    fi

    # Build summary
    local summary="[$APP_NAME] $component_name - Konflux compliance failure"

    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}[DRY RUN]${NC} Would create issue:"
        echo -e "${BLUE}Summary:${NC} $summary"
        echo -e "${BLUE}Project:${NC} $JIRA_PROJECT"
        echo -e "${BLUE}Type:${NC} $ISSUE_TYPE"
        echo -e "${BLUE}Priority:${NC} $PRIORITY"
        echo -e "${BLUE}Labels:${NC} $LABELS"
        echo ""
        echo "DRY-RUN-ISSUE"  # Output placeholder for dry-run mode
        return 0
    fi

    # Check for duplicates if requested
    if [[ "$SKIP_DUPLICATES" == true ]]; then
        local jql="project=$JIRA_PROJECT AND summary~\"$component_name\" AND labels IN (konflux,compliance) AND status NOT IN (Closed,Done,Resolved)"

        # Use jira-cli to search for existing issues
        local existing_issues=$(jira issue list --jql "$jql" --plain --no-headers --columns KEY 2>/dev/null || echo "")

        if [[ -n "$existing_issues" ]]; then
            local existing_key=$(echo "$existing_issues" | head -n 1 | awk '{print $1}' | xargs)
            echo -e "${YELLOW}⊘${NC} Skipping $component_name - similar issue already exists: $existing_key" >&2
            echo "$existing_key"  # Output existing issue key for tracking
            return 0
        fi
    fi

    # Create a temporary file for the description
    local desc_file=$(mktemp)
    echo "$description" > "$desc_file"

    # Build jira-cli command arguments
    local jira_cmd_args=(
        "issue" "create"
        "--project" "$JIRA_PROJECT"
        "--type" "$ISSUE_TYPE"
        "--priority" "$PRIORITY"
        "--summary" "$summary"
        "--template" "$desc_file"
        "--custom" "activity-type=Quality / Stability / Reliability"
        "--custom" "severity=Critical"
        "--no-input"
    )

    # Add labels
    if [[ -n "$LABELS" ]]; then
        IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
        for label in "${LABEL_ARRAY[@]}"; do
            label=$(echo "$label" | xargs)  # trim whitespace
            jira_cmd_args+=("--label" "$label")
        done
    fi

    # Add component - use squad name from component-squad.yaml unless overridden
    local jira_component="$COMPONENT"
    if [[ -z "$jira_component" ]]; then
        # Look up squad name for this component
        jira_component=$(get_component_squad "$component_name")
    fi

    if [[ -n "$jira_component" ]]; then
        jira_cmd_args+=("--component" "$jira_component")
    fi

    # Create the issue using jira-cli
    local output
    output=$(jira "${jira_cmd_args[@]}" 2>&1)
    local exit_code=$?

    # Clean up temp file
    rm -f "$desc_file"

    # Extract issue key from output
    # jira-cli typically outputs: "Issue created: PROJECT-123" or similar
    local issue_key=$(echo "$output" | grep -oE '[A-Z]+-[0-9]+' | head -n 1)

    if [[ $exit_code -eq 0 && -n "$issue_key" ]]; then
        # Get JIRA URL from jira-cli config
        local jira_url=$(jira config list 2>/dev/null | grep "server:" | awk '{print $2}' || echo "")
        if [[ -z "$jira_url" ]]; then
            jira_url="https://issues.redhat.com"
        fi
        echo -e "${GREEN}✓${NC} Created issue $issue_key for $component_name: $jira_url/browse/$issue_key" >&2
        echo "$issue_key"  # Output issue key for capture
        return 0
    else
        echo -e "${RED}✗${NC} Failed to create issue for $component_name: $output"
        return 1
    fi
}

# Function to check if a component is non-compliant
is_non_compliant() {
    local promotion_status="$1"
    local hermetic_status="$2"
    local ec_status="$3"
    local multiarch_status="$4"

    # Check for any failure conditions
    if [[ "$promotion_status" =~ (Failed|IMAGE_PULL_FAILURE|INSPECTION_FAILURE|DIGEST_FAILURE) ]] || \
       [[ "$hermetic_status" == "Not Enabled" ]] || \
       [[ "$ec_status" =~ (Not Compliant|Push Failure) ]] || \
       [[ "$multiarch_status" == "Not Enabled" ]]; then
        return 0  # true - is non-compliant
    fi

    return 1  # false - is compliant
}

# Main processing
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Konflux Compliance JIRA Issue Creator${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Project:${NC} $JIRA_PROJECT"
echo -e "${BLUE}Application:${NC} $APP_NAME"
echo -e "${BLUE}JIRA Auth Type:${NC} ${JIRA_AUTH_TYPE:-not set}"
echo ""

# Read compliance data from CSV
# The CSV format is: component_name,build_time,promotion_status,hermetic_status,ec_status,multiarch_status,push_pipelinerun_url,ec_pipelinerun_url
created_count=0
skipped_count=0
failed_count=0
total_count=0

declare -a created_issues
declare -a created_issues_json

echo -e "${BLUE}Starting to process CSV file: $COMPLIANCE_FILE${NC}" >&2
echo -e "${BLUE}File exists: $(test -f "$COMPLIANCE_FILE" && echo yes || echo no)${NC}" >&2
echo -e "${BLUE}File content (first 3 lines):${NC}" >&2
head -3 "$COMPLIANCE_FILE" >&2
echo "" >&2

while IFS=',' read -r component_name build_time promotion_status hermetic_status ec_status multiarch_status push_pipelinerun_url ec_pipelinerun_url; do
    total_count=$((total_count + 1))
    echo -e "${BLUE}DEBUG: Read line $total_count: component=$component_name${NC}" >&2

    # Skip empty lines
    if [[ -z "$component_name" ]]; then
        continue
    fi

    # Check if component is non-compliant
    if is_non_compliant "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status"; then
        echo -e "${BLUE}Processing:${NC} $component_name"

        issue_output=$(create_jira_issue "$component_name" "$build_time" "$promotion_status" "$hermetic_status" "$ec_status" "$multiarch_status" "$push_pipelinerun_url" "$ec_pipelinerun_url")
        create_exit_code=$?

        if [[ $create_exit_code -eq 0 ]]; then
            created_count=$((created_count + 1))
            # Extract the issue key (last line of output) and trim whitespace
            issue_key=$(echo "$issue_output" | tail -n 1 | xargs)
            created_issues+=("$component_name:$issue_key")
            if [[ -n "$OUTPUT_JSON" ]]; then
                # Store in JSON format as well
                created_issues_json+=("{\"component\": \"$component_name\", \"status\": \"created\", \"issue_key\": \"$issue_key\"}")
            fi
        else
            failed_count=$((failed_count + 1))
        fi
    else
        echo -e "${GREEN}✓${NC} $component_name is compliant - skipping"
        skipped_count=$((skipped_count + 1))
    fi

done < "$COMPLIANCE_FILE"

# Save output JSON if requested
if [[ -n "$OUTPUT_JSON" && ${#created_issues_json[@]} -gt 0 ]]; then
    printf "[%s]\n" "$(IFS=,; echo "${created_issues_json[*]}")" | jq '.' > "$OUTPUT_JSON"
    echo -e "${GREEN}✓${NC} Saved created issues to $OUTPUT_JSON"
fi

# Print summary
echo ""
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Summary${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "Total components processed: $total_count"
echo -e "${GREEN}Compliant (skipped):${NC} $skipped_count"
echo -e "${GREEN}Issues created:${NC} $created_count"
echo -e "${RED}Failed:${NC} $failed_count"

# Print list of created issues with URLs
if [[ ${#created_issues[@]} -gt 0 ]]; then
    echo ""
    echo -e "${BLUE}Issues:${NC}"
    # Get JIRA URL from jira-cli config file directly
    jira_config="${HOME}/.config/.jira/.config.yml"
    if [[ -f "$jira_config" ]]; then
        jira_url=$(grep "^[[:space:]]*server:" "$jira_config" | awk '{print $2}' | tr -d '"' || echo "https://issues.redhat.com")
    else
        jira_url="https://issues.redhat.com"
    fi
    for issue_info in "${created_issues[@]}"; do
        comp_name="${issue_info%%:*}"
        issue_key="${issue_info##*:}"
        # Trim any whitespace from issue key
        issue_key=$(echo "$issue_key" | xargs)
        echo -e "  • $comp_name: $jira_url/browse/$issue_key"
    done
fi

if [[ "$DRY_RUN" == true ]]; then
    echo ""
    echo -e "${YELLOW}This was a dry run. No issues were actually created.${NC}"
    echo -e "Remove --dry-run flag to create issues."
fi

exit 0
